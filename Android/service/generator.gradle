
import java.util.regex.Matcher
import java.util.regex.Pattern

/**
 * Created by JBruchanov on 05/02/2016.
 */

ext {
    generateHelpClass = this.&generateHelpClass
    PATTERN = Pattern.compile("\\.put\\(\\\"([^\\\"]+):\",\\s*([^;]*)\\);")
    PATTERN_METHOD = Pattern.compile("\\.(\\w+)\\(\\)(\\[(\\d+)\\])?")
}

class CodePiece {
    String method;
    int arrayIndex;

    CodePiece(String method, int arrayIndex) {
        this.method = method
        this.arrayIndex = arrayIndex
    }

    @Override
    boolean equals(Object obj) {
        if (obj instanceof CodePiece) {
            return method.equals(obj.method) && arrayIndex == obj.arrayIndex
        }
        return false
    }

    @Override
    int hashCode() {
        Objects.hash(method, arrayIndex)
    }

    @Override
    String toString() {
        return method + (arrayIndex < 0 ? "()" : "()[" + arrayIndex + "]")
    }
}


def generateHelpClass(String srcLocation) {

    def fileFilter = new FileFilter() {
        @Override
        boolean accept(File pathname) {
            return pathname.name.endsWith("Extractor.java");
        }
    }

    def result = new HashMap<String, CodePiece>()
    List<File> files = getFiles(new File(srcLocation), new ArrayList<File>(), fileFilter)
    for (File file : files) {
        def subResult = parseFile(file)
        for (String key : subResult.keySet()) {
            if (!result.containsKey(key)) {
                result.put(key, subResult.get(key))
            } else if (subResult.get(key).equals(result.get(key))) {
                System.err.println("Difference piece code:'%s' vs '%s' for key:'%s'".format(subResult.get(key).toString(), result.get(key).toString(), key))
            }
        }
    }

    def sb = new StringBuilder();
    sb.append("package com.scurab.android.anuitor.reflect;\n\n")
    sb.append("import java.util.Map;\n")
    sb.append("import java.util.HashMap;\n")
    sb.append("import java.util.Collections;\n\n")
    sb.append("/* Auto generated class, do not update! */\n\n")
    sb.append("public final class ReflectionHelper {\n\n")
    sb.append("\tpublic static final Map<String, Item> ITEMS;\n\n")
    sb.append("\tstatic {\n")
    sb.append("\t\tHashMap<String, Item> items = new HashMap<>();\n\n")
    def list = new ArrayList(result.keySet())
    Collections.sort(list)
    for (String key : list) {
        def pc = result.get(key)
        sb.append(String.format("\t\titems.put(\"%s\", new Item(\"%s\", %s));\n", key, pc.method, pc.arrayIndex))
    }
    sb.append("\n\t\tITEMS = Collections.unmodifiableMap(items);\n")
    sb.append("\t}\n")
    sb.append("\n\tpublic static class Item {\n")
    sb.append("\t\tpublic final String methodName;\n")
    sb.append("\t\tpublic final int arrayIndex;\n\n")
    sb.append("\t\tpublic Item(String methodName, int arrayIndex) {\n")
    sb.append("\t\t\tthis.methodName = methodName;\n")
    sb.append("\t\t\tthis.arrayIndex = arrayIndex;\n")
    sb.append("\t\t}\n")
    sb.append("\t}\n")
    sb.append("}\n")

    return sb.toString().replaceAll("\t", "    ");
}

def List<File> getFiles(File file, List<File> output, FileFilter ff) {
    if (file != null) {
        def files = file.listFiles()
        for (File f : files) {
            if (f.isDirectory()) {
                getFiles(f, output, ff)
            } else {
                if (ff.accept(f)) {
                    output.add(f);
                }
            }
        }
    }
    return output;
}

def HashMap<String, CodePiece> parseFile(File file) {
    String content = file.text;
    Matcher m = PATTERN.matcher(content)
    def result = new HashMap<String, String>()
    while (m.find()) {
        String key = m.group(1)
        String code = m.group(2)
        def cp = parseCode(code)
        if (cp != null) {
            result.put(key, cp)
        }
    }
    return result;
}

def parseCode(String code) {
    Matcher matcher = PATTERN_METHOD.matcher(code)
    if (matcher.find()) {
        def method = matcher.group(1)
        def arrayIndex = -1
        if (matcher.groupCount() > 2) {
            def index = matcher.group(3)
            arrayIndex = index != null ? Integer.parseInt(matcher.group(3)) : -1
        }
        return new CodePiece(method, arrayIndex)
    } else {
        System.err.println("'%s' doesn't match with regexp".format(code))
    }
    return null
}